from fortis.engine.models.building_mapping import BuildingMapping
import pytest
from fortis.engine.vulnerability.default_flood import DefaultFloodFunction

@pytest.fixture
def default_flood_function(small_udf_buildings):
    return DefaultFloodFunction(
        buildings=small_udf_buildings, flood_type="CV"
    )


def test_apply_damage_percentages(default_flood_function, small_udf_buildings):
    # ARRANGE
    fields = small_udf_buildings.fields

    # ACT
    default_flood_function.apply_damage_percentages()

    # ASSERT
    assert small_udf_buildings.gdf[fields.bddf_id].notna().all(), (
        "Not all BDDF_ID values are populated."
    )

    assert (
        small_udf_buildings.gdf["BldgDmgPct"]
        .astype(float)
        .equals(round(small_udf_buildings.gdf["BuildingDamagePct"].astype(float), 6))
    ), "Building Damage Pct is not as expected"

    assert (
        small_udf_buildings.gdf["ContDmgPct"]
        .astype(float)
        .equals(round(small_udf_buildings.gdf["ContentDamagePct"].astype(float), 6))
    ), "Content Damage Pct is not as expected"

    """
    assert (
        small_udf_buildings.gdf["InvDmgPct"]
        .astype(float)
        .equals(round(small_udf_buildings.gdf["InventoryDamagePct"].astype(float), 6))
    ), "Inventory Damage Pct is not as expected"
    """

def test_apply_damage_ids_vectorized(default_flood_function, small_udf_buildings):
    # ARRANGE
    small_udf_buildings.fields = BuildingMapping(overrides = {
            "id": "Id",
            "occupancy_type": "OccupancyType",
            # All of these below here should be the defaults but if that changes overridding
            "first_floor_height": "FirstFloorHt",
            "foundation_type": "FoundationType",
            "number_stories": "NumStories",
            "area": "Area",
            "building_cost": "Cost",
            "content_cost": "ContentCostUSD",
            "inventory_cost": "InventoryCostUSD",
            # These can be added if missing below this line
            "flood_depth": "Depth_Grid",
            "depth_in_structure": "Depth_in_Struc",
            "bddf_id": "BldgDmgFnId",
            "building_damage_percent": "BuildingDamagePct",
            "building_loss": "BldgLossUSD",
            "cddf_id": "ContDmgFnId",
            "content_damage_percent": "ContentDamagePct",
            "content_loss": "ContentLossUSD",
            "iddf_id": "IDDF_ID",
            "inventory_damage_percent": "InventoryDamagePct",
            "inventory_loss": "InventoryLossUSD",
            "debris_finish": "DebrisFinish",
            "debris_foundation": "DebrisFoundation",
            "debris_structure": "DebrisStructure",
            "debris_total": "DebrisTotal",
        })
    fields = small_udf_buildings.fields
    
    small_udf_buildings.gdf[fields.bddf_id] = None
    small_udf_buildings.gdf[fields.cddf_id] = None
    small_udf_buildings.gdf[fields.iddf_id] = None
    
    # ACT
    default_flood_function.apply_damage_ids_vectorized()
    
    # Export only specific columns
    columns_to_export = ["Id", "OccupancyType", "FoundationType", "NumStories", "Basement", "BDDF_ID", "BldgDmgFnId", "CDDF_ID", "ContDmgFnId", "IDDF_ID"]
    small_udf_buildings.gdf[columns_to_export].to_csv("C:/temp/gbs_lookup.csv", index=False)


    # ASSERT
    assert small_udf_buildings.gdf[fields.bddf_id].notna().all(), (
        "Not all building damage IDs were populated"
    )
    
    assert small_udf_buildings.gdf[fields.cddf_id].notna().all(), (
        "Not all content damage IDs were populated"
    )
    
    if fields.iddf_id in small_udf_buildings.gdf.columns:
        assert small_udf_buildings.gdf[fields.iddf_id].notna().any(), (
            "Not all inventory damage IDs were populated"
        )

def test_flood_type_handling(small_udf_buildings):
    # ARRANGE & ACT
    riverine_function = DefaultFloodFunction(
        buildings=small_udf_buildings, flood_type="R"
    )
    
    coastal_v_function = DefaultFloodFunction(
        buildings=small_udf_buildings, flood_type="CV"
    )
    
    coastal_a_function = DefaultFloodFunction(
        buildings=small_udf_buildings, flood_type="CA"
    )
    
    # ASSERT - Just verify they initialize correctly
    assert riverine_function.flood_type == "R"
    assert coastal_v_function.flood_type == "CV"
    assert coastal_a_function.flood_type == "CA"
    
    # Test invalid flood type
    with pytest.raises(ValueError, match="Invalid flood_type"):
        riverine_function.flood_type = "INVALID"
        riverine_function.apply_damage_ids_vectorized()

def test_interpolate_from_lookup(default_flood_function, small_udf_buildings):
    # ARRANGE
    fields = small_udf_buildings.fields
    
    # First apply damage IDs 
    default_flood_function.apply_damage_ids_vectorized()
    
    # Manually set a known depth in structure for predictable results
    test_depth = 2.5
    small_udf_buildings.gdf[fields.depth_in_structure] = test_depth
    
    # ACT
    default_flood_function._interpolate_from_lookup(
        default_flood_function.bdf,
        fields.depth_in_structure,
        fields.building_damage_percent,
        fields.bddf_id
    )
    
    # ASSERT
    assert small_udf_buildings.gdf[fields.building_damage_percent].notna().all(), (
        "Not all building damage percentages were populated"
    )
    
    # The values should be between the ft02 and ft03 values in the lookup table
    for idx, row in small_udf_buildings.gdf.iterrows():
        bddf_id = row[fields.bddf_id]
        if bddf_id == 0:  # Skip if no mapping found
            continue
        
        if bddf_id in default_flood_function.bdf.index:
            ft02_val = default_flood_function.bdf.loc[bddf_id, 'ft02']
            ft03_val = default_flood_function.bdf.loc[bddf_id, 'ft03']
            
            interpolated_val = row[fields.building_damage_percent]
            assert ft02_val <= interpolated_val <= ft03_val or ft03_val <= interpolated_val <= ft02_val, (
                f"Interpolated value {interpolated_val} not between ft02 ({ft02_val}) and ft03 ({ft03_val})"
            )

def test_end_to_end_damage_calculation(default_flood_function, small_udf_buildings):
    # ARRANGE
    fields = small_udf_buildings.fields
    
    # ACT - Run the full damage calculation
    default_flood_function.apply_damage_ids_vectorized()
    default_flood_function.apply_damage_percentages()
    
    # ASSERT
    assert small_udf_buildings.gdf[fields.building_damage_percent].notna().all(), (
        "Not all building damage percentages were calculated"
    )
    
    assert small_udf_buildings.gdf[fields.content_damage_percent].notna().all(), (
        "Not all content damage percentages were calculated"
    )
    
    # Check values are within valid range
    assert (small_udf_buildings.gdf[fields.building_damage_percent] >= 0).all(), "Building damage values below 0"
    assert (small_udf_buildings.gdf[fields.building_damage_percent] <= 1).all(), "Building damage values above 1"
    
    assert (small_udf_buildings.gdf[fields.content_damage_percent] >= 0).all(), "Content damage values below 0" 
    assert (small_udf_buildings.gdf[fields.content_damage_percent] <= 1).all(), "Content damage values above 1"

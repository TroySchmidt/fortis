import numpy as np
import pandas as pd
from fortis.engine.models.abstract_building_points import AbstractBuildingPoints
from fortis.engine.vulnerability.abstract_vulnerability_function import (
    AbstractVulnerabilityFunction,
)
import importlib.resources as pkg_resources

class DefaultFloodFunction(AbstractVulnerabilityFunction):
    def __init__(
        self,
        buildings: AbstractBuildingPoints,
        flood_type,
    ):
        """
        Initializes a DefaultFloodFunction object.

        Args:
            buildings (BuildingPoints): BuildingPoints object.
            flood_type (str): The type of flood to analyze (R, CV, CA).
        """
        self.flood_type = flood_type
        self.buildings = buildings

        # Use package resources to load CSV files from the fortis_data package.
        with (
            pkg_resources.files("fortis.data")
            .joinpath("flBldgDmgFn.csv")
            .open("r", encoding="utf-8-sig") as bdf_file
        ):
            self.bdf = pd.read_csv(bdf_file)
        with (
            pkg_resources.files("fortis.data")
            .joinpath("flContDmgFn.csv")
            .open("r", encoding="utf-8-sig") as cdf_file
        ):
            self.cdf = pd.read_csv(cdf_file)
        with (
            pkg_resources.files("fortis.data")
            .joinpath("flInvDmgFn.csv")
            .open("r", encoding="utf-8-sig") as idf_file
        ):
            self.idf = pd.read_csv(idf_file)
        with (
            pkg_resources.files("fortis.data")
            .joinpath("flDmgXRef.csv")
            .open("r", encoding="utf-8-sig") as xdf_file
        ):
            self.xdf = pd.read_csv(xdf_file)

        self.bdf = self.bdf.set_index("BldgDmgFnID")
        self.cdf = self.cdf.set_index("ContDmgFnId")
        self.idf = self.idf.set_index("InvDmgFnId")
        self.xdf = self.xdf.set_index(
            [
                "Occupancy",
                "Basement",
                "StoriesMin",
                "StoriesMax",
                "HazardR",
                "HazardCV",
                "HazardCA",
            ]
        )

        # self.xRefExecuted = False

    def get_damage_id_from_xref(self, occupancy, basement, stories, dmgIdField):
        """
        Retrieves the damage ID from the cross reference table.
        Args:
            occupancy (str): The occupancy type.
            basement (int): The basement type.
            stories (int): The number of stories.
            dmgIdField (str): The damage ID field to retrieve.

        Returns:
            int: The damage ID
        """
        # Retrieve function ID from cross reference table
        # Handle special case for RES3 occupancy
        if occupancy.startswith("RES3") and not occupancy[-1].isdigit():
            occupancy = occupancy[:-1]

        conditions = [
            (occupancy == self.xdf.index.get_level_values("Occupancy")),
            (basement == self.xdf.index.get_level_values("Basement")),
            (stories >= self.xdf.index.get_level_values("StoriesMin")),
            (stories <= self.xdf.index.get_level_values("StoriesMax")),
        ]

        # This is incorrect.  It is riverine or coastal.  If coastal it uses all three based on depth (wave action)
        if self.flood_type == "R":
            conditions.append(self.xdf.index.get_level_values("HazardR") == 1)
        elif self.flood_type == "CV":
            conditions.append(self.xdf.index.get_level_values("HazardCV") == 1)
        elif self.flood_type == "CA":
            conditions.append(self.xdf.index.get_level_values("HazardCA") == 1)

        self.xRef = self.xdf[np.logical_and.reduce(conditions)]

        return (
            0
            if len(self.xRef[dmgIdField].values) == 0
            else (
                self.xRef[dmgIdField].values[0]
                if not pd.isna(self.xRef[dmgIdField].values[0])
                else 0
            )
        )

    def apply_damage_percentages(self):
        """
        Gathers the damage percentages for building, content, and inventory

        Args:

        Returns:

        """
        # Add ouptut columns to building_points
        fields = self.buildings.fields
        gdf = self.buildings.gdf

        gdf["BuildingDamagePct"] = None
        
        # Handle depth value, calculate corresponding upper/lower indices (field names)
        depths = gdf[self.buildings.fields.depth_in_structure].clip(lower=-4, upper=24)
        l_indices = (
            "ft"
            + depths.abs().floordiv(1).astype(int).astype(str).str.zfill(2)
            + depths.lt(0).map({True: "m", False: ""})
        )
        u_indices = (
            "ft"
            + np.ceil(depths.abs()).astype(int).astype(str).str.zfill(2)
            + depths.lt(0).map({True: "m", False: ""})
        )
        fracs = depths - depths.floordiv(1)

        # Retrieve function IDs from cross reference table
        bldgXrefIds = gdf.apply(
            lambda row: self.get_damage_id_from_xref(
                row[fields.occupancy_type],
                1 if row[fields.foundation_type] == 4 else 0,
                row[fields.number_stories],
                "BldgDmgFnId",
            ),
            axis=1,
        )
        contXrefIds = gdf.apply(
            lambda row: self.get_damage_id_from_xref(
                row[fields.occupancy_type],
                1 if row[fields.foundation_type] == 4 else 0,
                row[fields.number_stories],
                "ContDmgFnId",
            ),
            axis=1,
        )
        invXrefIds = gdf.apply(
            lambda row: self.get_damage_id_from_xref(
                row[fields.occupancy_type],
                1 if row[fields.foundation_type] == 4 else 0,
                row[fields.number_stories],
                "InvDmgFnId",
            ),
            axis=1,
        )

        # Update building points with cross reference IDs if not provided
        gdf[fields.bddf_id] = gdf[fields.bddf_id].apply(
            lambda x: bldgXrefIds[x.name] if pd.isna(x) or x == 0 else x
        )
        gdf[fields.cddf_id] = gdf[fields.cddf_id].apply(
            lambda x: contXrefIds[x.name] if pd.isna(x) or x == 0 else x
        )
        gdf[fields.iddf_id] = gdf.apply(
            lambda row: invXrefIds[row.name]
            if pd.isna(row[fields.iddf_id]) or row[fields.iddf_id] == 0
            else row[fields.iddf_id],
            axis=1,
        )

        gdf["BuildingDamagePct"] = self._calculate_damage_pct(
            l_indices, u_indices, fracs, gdf, fields.bddf_id, self.bdf
        )
        gdf["ContentDamagePct"] = self._calculate_damage_pct(
            l_indices, u_indices, fracs, gdf, fields.cddf_id, self.cdf
        )
        gdf["InventoryDamagePct"] = self._calculate_damage_pct(
            l_indices, u_indices, fracs, gdf, fields.iddf_id, self.idf
        )

    def _calculate_damage_pct(self, l_indices, u_indices, fracs, df, dmg_field, dmg_df):
        lower_values = df.apply(
            lambda row: dmg_df.at[row[dmg_field], l_indices[row.name]]
            if row[dmg_field] != 0
            else 0,
            axis=1,
        )
        upper_values = df.apply(
            lambda row: dmg_df.at[row[dmg_field], u_indices[row.name]]
            if row[dmg_field] != 0
            else 0,
            axis=1,
        )
        return lower_values + fracs * (upper_values - lower_values)

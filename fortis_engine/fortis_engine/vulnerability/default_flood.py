import math
import numpy as np
import os
import pandas as pd
import geopandas as gpd
from fortis_engine.models.abstract_building_points import AbstractBuildingPoints

try:
    # Python 3.9+
    import importlib.resources as resources
except ImportError:
    # For earlier versions, install importlib_resources
    import importlib_resources as resources

class DefaultFloodFunction:
    def __init__(self, flood_type, **params):
        """
        Initializes a DefaultFloodFunction object.

        Args:
            **params: Parameters for the vulnerability function.
        """
        self.flood_type = flood_type
        self.params = params

        # Use package resources to load CSV files from the fortis_data package.
        with resources.open_text("fortis_data.data", "flBldgStructDmgFn.csv") as bdf_file:
            self.bdf = pd.read_csv(bdf_file)
        with resources.open_text("fortis_data.data", "flBldgContDmgFn.csv") as cdf_file:
            self.cdf = pd.read_csv(cdf_file)
        with resources.open_text("fortis_data.data", "flBldgInvDmgFn.csv") as idf_file:
            self.idf = pd.read_csv(idf_file)
        with resources.open_text("fortis_data.data", "flBldgDmgXRef.csv") as xdf_file:
            self.xdf = pd.read_csv(xdf_file)

        self.bdf = self.bdf.set_index("BldgDmgFnID")
        self.cdf = self.cdf.set_index("ContDmgFnId")
        self.idf = self.idf.set_index("InvDmgFnId")
        self.xdf = self.xdf.set_index(["Occupancy", "Basement", "StoriesMin", "StoriesMax", "HazardR", "HazardCV", "HazardCA"])

        self.xRefExecuted = False

    def get_damage_id_from_xref(self, occupancy, basement, stories, dmgIdField):
        # Retrieve function ID from cross reference table if not previously done
        if not self.xRefExecuted:
            # Handle special case for RES3 occupancy
            if occupancy.startswith("RES3") and not occupancy[-1].isdigit():
                occupancy = occupancy[:-1]

            conditions = [
                (occupancy == self.xdf.index.get_level_values("Occupancy")),
                (basement == self.xdf.index.get_level_values("Basement")),
                (stories >= self.xdf.index.get_level_values("StoriesMin")),
                (stories <= self.xdf.index.get_level_values("StoriesMax"))
            ]

            if self.flood_type == "R":
                conditions.append(self.xdf.index.get_level_values("HazardR") == 1)
            elif self.flood_type == "CV":
                conditions.append(self.xdf.index.get_level_values("HazardCV") == 1)
            elif self.flood_type == "CA":
                conditions.append(self.xdf.index.get_level_values("HazardCA") == 1)

            self.xRef = self.xdf[np.logical_and.reduce(conditions)]
            self.xRefExecuted = True
        
        return self.xRef[dmgIdField].values[0] if len(self.xRef[dmgIdField].values) > 0 else None
       
    def collect_damage_percentages(self, building_points: AbstractBuildingPoints):
        """
        Gathers the damage percentages for building, content, and inventory

        Args:

        Returns:

        """
        # Add ouptut columns to building_points
        building_points.gdf["BuildingDamagePct"] = None
        building_points.gdf["ContentDamagePct"] = None
        building_points.gdf["InventoryDamagePct"] = None

        # FOR TESTING
        bldgDmgField = "BDDF_ID"
        contDmgField = "CDDF_ID"
        invDmgField = "IDDF_ID"

        # Calculate damage for each building
        for row in building_points.gdf.itertuples(index=True): # TODO Need to modernize this to not loop but vectorization
            # Handle depth value, calculate corresponding upper/lower indices (field names)
            depth = row.Depth_in_Struc
            depth = 24 if depth > 24 else depth
            depth = -4 if depth < -4 else depth
            l = str(int(abs(math.floor(depth))))
            u = str(int(abs(math.ceil(depth))))
            suffix_l = 'm' if math.floor(depth) < 0 else ''
            suffix_u = 'm' if math.ceil(depth) < 0 else ''
            l_index = 'ft' + str(l).zfill(2) + suffix_l
            u_index = 'ft' + str(u).zfill(2) + suffix_u

            # Gather values to perform default damage function lookup (if needed)
            occupancy = row.Occ
            basement = 1 if row.FoundationType == 4 else 0
            stories = row.NumStories
        
            ###########################################################
            # BUILDING DAMAGE PERCENTAGE
            ###########################################################
            # Use BldgDamageFnID if provided, otherwise perform default lookup
            ddfb = None
            if pd.notna(getattr(row, bldgDmgField)):
                ddfb = self.bdf.loc[getattr(row, bldgDmgField)]
            else:
                # Retrieve function ID from cross reference table
                bldgXrefId = self.get_damage_id_from_xref(occupancy, basement, stories, "StructDmgFnId")
                if pd.notna(bldgXrefId) and bldgXrefId != 0:
                    ddfb = self.bdf.loc[[bldgXrefId]]
                    building_points.gdf.at[row.Index, bldgDmgField] = bldgXrefId
                else:
                    building_points.gdf.at[row.Index, bldgDmgField] = 0
        
            # Calculate BuildingDamagePct
            if ddfb is not None and not ddfb.empty:
                d_lower = float(ddfb[l_index])
                d_upper = float(ddfb[u_index])
                # Get fractional amount of depth, for interpolation
                frac = depth - math.floor(depth)
                building_points.gdf.at[row.Index, "BuildingDamagePct"] = (d_lower + frac*(d_upper - d_lower))
            else:
                building_points.gdf.at[row.Index, "BuildingDamagePct"] = 0.0

            ###########################################################
            # CONTENT DAMAGE PERCENTAGE
            ###########################################################
            # Use CDDF_ID if provided, otherwise perform default lookup
            ddfc = None
            if pd.notna(getattr(row, contDmgField)):
                ddfc = self.cdf.loc[getattr(row, contDmgField)]
            else:
                # Retrieve function ID from cross reference table
                contXrefId = self.get_damage_id_from_xref(occupancy, basement, stories, "ContDmgFnId")
                if pd.notna(contXrefId) and contXrefId != 0:
                    ddfc = self.cdf.loc[[contXrefId]]
                    building_points.gdf.at[row.Index, contDmgField] = contXrefId
                else:
                    building_points.gdf.at[row.Index, contDmgField] = 0
        
            # Calculate ContentDamagePct
            if ddfc is not None and not ddfc.empty:
                d_lower = float(ddfc[l_index])
                d_upper = float(ddfc[u_index])
                frac = depth - math.floor(depth)
                building_points.gdf.at[row.Index, "ContentDamagePct"] = (d_lower + frac*(d_upper - d_lower))
            else:
                building_points.gdf.at[row.Index, "ContentDamagePct"] = 0.0

            ###########################################################
            # INVENTORY DAMAGE PERCENTAGE
            ###########################################################
            # Use IDDF_ID if provided, otherwise perform default lookup
            ddfi = None
            if pd.notna(getattr(row, invDmgField)):
                ddfi = self.idf.loc[getattr(row, invDmgField)]
            else:
                # Retrieve function ID from cross reference table
                invXrefId = self.get_damage_id_from_xref(occupancy, basement, stories, "InvDmgFnId")
                if pd.notna(invXrefId) and invXrefId != 0:
                    ddfi = self.idf.loc[[invXrefId]]
                    building_points.gdf.at[row.Index, invDmgField] = invXrefId
                else:
                    building_points.gdf.at[row.Index, invDmgField] = 0
        
            # Calculate InventoryDamagePct
            if ddfi is not None and not ddfi.empty:
                d_lower = float(ddfi[l_index])
                d_upper = float(ddfi[u_index])
                frac = depth - math.floor(depth)
                building_points.gdf.at[row.Index, "InventoryDamagePct"] = (d_lower + frac*(d_upper - d_lower))
            else:
                building_points.gdf.at[row.Index, "InventoryDamagePct"] = 0.0

            self.xRefExecuted = False
            self.xRef = None

            #print(str(row.Index) + ": " + str(row._1) + ", B: " + str(building_points.gdf.data.at[row.Index, "BuildingDamagePct"]) + " | " + str(row.BuildingDamagePct_Expected) + ", C: " + str(building_points.gdf.data.at[row.Index, "ContentDamagePct"]) + " | " + str(row.ContentDamagePct_Expected) + ", I: " + str(building_points.gdf.data.at[row.Index, "InventoryDamagePct"]) + " | " + str(row.InventoryDamagePct_Expected))

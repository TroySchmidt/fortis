import math
import numpy as np
import os
import pandas as pd
import geopandas as gpd
class DefaultFloodFunction:
    def __init__(self, func_type, building_points, flood_type, **params):
      """
      Initializes a DefaultFloodFunction object.

      Args:
          func_type (str): Type of vulnerability function (e.g., 'RISK-UE', 'LM1').
          building_points (BuildingPoints): concrete implementation of AbstractBuildingPoints that contains building data.
          flood_type (str): Type of flood hazard ('R', 'CV', 'CA').
          **params: Parameters for the vulnerability function.
      """
      self.func_type = func_type
      self.building_points = building_points
      self.flood_type = flood_type
      self.params = params

      # Collect dataframes: flBldgContDmgFn, flBldgInvDmgFn, flBldgStructDmgFn (damage function lookups);   flBldgDmgXRef (cross reference table)
      data_folder = os.path.join(os.path.dirname(__file__), "../../../fortis_data/data/")
      self.bdf = pd.read_csv(os.path.join(data_folder, "flBldgStructDmgFn.csv"))
      self.cdf = pd.read_csv(os.path.join(data_folder, "flBldgContDmgFn.csv"))
      self.idf = pd.read_csv(os.path.join(data_folder, "flBldgInvDmgFn.csv"))
      self.xdf = pd.read_csv(os.path.join(data_folder, "flBldgDmgXRef.csv"))

      self.bdf = self.bdf.set_index("BldgDmgFnID")
      self.cdf = self.cdf.set_index("ContDmgFnId")
      self.idf = self.idf.set_index("InvDmgFnId")
      self.xdf = self.xdf.set_index(["Occupancy", "Basement", "StoriesMin", "StoriesMax", "HazardR", "HazardCV", "HazardCA"])

      self.xRefExecuted = False

    def get_damage_id_from_xref(self, occupancy, basement, stories, dmgIdField):
      """
      Performs damage function lookup based on building characteristics.

      Args:
          occupancy (str): Building occupancy type.
          basement (int): If basement is present (1) or not (0).
          stories (float): Number of stories.
          dmgIdField (str): Field name for the damage function ID.
          **params: Parameters for the vulnerability function.
      """
      # Retrieve function ID from cross reference table if not previously done
      if not self.xRefExecuted:
        # Handle special case for RES3 occupancy
        if occupancy.startswith("RES3") and not occupancy[-1].isdigit():
           occupancy = occupancy[:-1]

        conditions = [
            (occupancy == self.xdf.index.get_level_values("Occupancy")),
            (basement == self.xdf.index.get_level_values("Basement")),
            (stories >= self.xdf.index.get_level_values("StoriesMin")),
            (stories <= self.xdf.index.get_level_values("StoriesMax"))
        ]

        # Add hazard type condition
        if self.flood_type == "R":
            conditions.append(self.xdf.index.get_level_values("HazardR") == 1)
        elif self.flood_type == "CV":
            conditions.append(self.xdf.index.get_level_values("HazardCV") == 1)
        elif self.flood_type == "CA":
            conditions.append(self.xdf.index.get_level_values("HazardCA") == 1)
            
        self.xRef = self.xdf[np.logical_and.reduce(conditions)]
        self.xRefExecuted = True
      
      # Handle special case for split level RES occupancy
      if len(self.xRef) > 1:
        if stories.is_integer():
          self.xRef = self.xRef[~self.xRef['Description'].str.startswith('split level')]
        else:
          self.xRef = self.xRef[self.xRef['Description'].str.startswith('split level')]
        
      return self.xRef[dmgIdField].values[0] if len(self.xRef[dmgIdField].values) > 0 else None

    def calculate_damage(self, intensity):
      """
      Calculates damage based on hazard intensity and the vulnerability function.

      Args:
          intensity (float): Hazard intensity value.

      Returns:
          float: Damage estimate.
      """
      
      # In the case of Hazus, intensity is the flood depth and then the result is the percentage of damage
      
      # Implement damage calculation based on func_type and params
      if self.func_type == 'RISK-UE':
          # Example: RISK-UE vulnerability function (replace with actual implementation)
          damage = self.params['a'] * intensity ** self.params['b']
          return damage
      elif self.func_type == 'LM1':
          # Example: LM1 vulnerability function (replace with actual implementation)
          damage =  0
          return damage
      else:
          raise ValueError("Unsupported vulnerability function type.")
       
    def collect_damage_percentages(self):
      """
      Gathers the damage percentages for building, content, and inventory

      Args:

      Returns:

      """
      # Add ouptut columns to building_points
      self.building_points.data["BuildingDamagePct"] = None
      self.building_points.data["ContentDamagePct"] = None
      self.building_points.data["InventoryDamagePct"] = None

      # FOR TESTING
      bldgDmgField = "BDDF_ID"
      contDmgField = "CDDF_ID"
      invDmgField = "IDDF_ID"

      # Calculate damage for each building
      for row in self.building_points.data.itertuples(index=True):
        # Handle depth value, calculate corresponding upper/lower indices (field names)
        depth = row.Depth_in_Struc
        depth = 24 if depth > 24 else depth
        depth = -4 if depth < -4 else depth
        l = str(int(abs(math.floor(depth))))
        u = str(int(abs(math.ceil(depth))))
        suffix_l = 'm' if math.floor(depth) < 0 else ''
        suffix_u = 'm' if math.ceil(depth) < 0 else ''
        l_index = 'ft' + str(l).zfill(2) + suffix_l
        u_index = 'ft' + str(u).zfill(2) + suffix_u

        # Gather values to perform default damage function lookup (if needed)
        occupancy = row.Occupancy
        basement = 1 if row.FoundationType == 4 else 0
        stories = row.NumStories
        
        ###########################################################
        # BUILDING DAMAGE PERCENTAGE
        ###########################################################
        # Use BldgDamageFnID if provided, otherwise perform default lookup
        ddfb = None
        if pd.notna(getattr(row, bldgDmgField)):
            ddfb = self.bdf.loc[getattr(row, bldgDmgField)]
        else:
            # Retrieve function ID from cross reference table
            bldgXrefId = self.get_damage_id_from_xref(occupancy, basement, stories, "StructDmgFnId")
            if pd.notna(bldgXrefId) and bldgXrefId != 0:
                ddfb = self.bdf.loc[[bldgXrefId]]
                self.building_points.data.at[row.Index, bldgDmgField] = bldgXrefId
            else:
                self.building_points.data.at[row.Index, bldgDmgField] = 0
        
        # Calculate BuildingDamagePct
        if ddfb is not None and not ddfb.empty:
            d_lower = float(ddfb[l_index])
            d_upper = float(ddfb[u_index])
            # Get fractional amount of depth, for interpolation
            frac = depth - math.floor(depth)
            self.building_points.data.at[row.Index, "BuildingDamagePct"] = (d_lower + frac*(d_upper - d_lower))
        else:
            self.building_points.data.at[row.Index, "BuildingDamagePct"] = 0.0

        ###########################################################
        # CONTENT DAMAGE PERCENTAGE
        ###########################################################
        # Use CDDF_ID if provided, otherwise perform default lookup
        ddfc = None
        if pd.notna(getattr(row, contDmgField)):
           ddfc = self.cdf.loc[getattr(row, contDmgField)]
        else:
            # Retrieve function ID from cross reference table
            contXrefId = self.get_damage_id_from_xref(occupancy, basement, stories, "ContDmgFnId")
            if pd.notna(contXrefId) and contXrefId != 0:
                ddfc = self.cdf.loc[[contXrefId]]
                self.building_points.data.at[row.Index, contDmgField] = contXrefId
            else:
                self.building_points.data.at[row.Index, contDmgField] = 0
        
        # Calculate ContentDamagePct
        if ddfc is not None and not ddfc.empty:
            d_lower = float(ddfc[l_index])
            d_upper = float(ddfc[u_index])
            frac = depth - math.floor(depth)
            self.building_points.data.at[row.Index, "ContentDamagePct"] = (d_lower + frac*(d_upper - d_lower))
        else:
            self.building_points.data.at[row.Index, "ContentDamagePct"] = 0.0

        ###########################################################
        # INVENTORY DAMAGE PERCENTAGE
        ###########################################################
        # Use IDDF_ID if provided, otherwise perform default lookup
        ddfi = None
        if pd.notna(getattr(row, invDmgField)):
           ddfi = self.idf.loc[getattr(row, invDmgField)]
        else:
            # Retrieve function ID from cross reference table
            invXrefId = self.get_damage_id_from_xref(occupancy, basement, stories, "InvDmgFnId")
            if pd.notna(invXrefId) and invXrefId != 0:
                ddfi = self.idf.loc[[invXrefId]]
                self.building_points.data.at[row.Index, invDmgField] = invXrefId
            else:
                self.building_points.data.at[row.Index, invDmgField] = 0
        
        # Calculate InventoryDamagePct
        if ddfi is not None and not ddfi.empty:
            d_lower = float(ddfi[l_index])
            d_upper = float(ddfi[u_index])
            frac = depth - math.floor(depth)
            self.building_points.data.at[row.Index, "InventoryDamagePct"] = (d_lower + frac*(d_upper - d_lower))
        else:
            self.building_points.data.at[row.Index, "InventoryDamagePct"] = 0.0

        self.xRefExecuted = False
        self.xRef = None

        #print(str(row.Index) + ": " + str(row._1) + ", B: " + str(self.building_points.data.at[row.Index, "BuildingDamagePct"]) + " | " + str(row.BuildingDamagePct_Expected) + ", C: " + str(self.building_points.data.at[row.Index, "ContentDamagePct"]) + " | " + str(row.ContentDamagePct_Expected) + ", I: " + str(self.building_points.data.at[row.Index, "InventoryDamagePct"]) + " | " + str(row.InventoryDamagePct_Expected))
